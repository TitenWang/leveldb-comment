// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file. See the AUTHORS file for names of contributors.
//
// Decodes the blocks generated by block_builder.cc.

#include "table/block.h"

#include <vector>
#include <algorithm>
#include "leveldb/comparator.h"
#include "table/format.h"
#include "util/coding.h"
#include "util/logging.h"

namespace leveldb {

// 一个Block的内存布局：
// ------------------
// |    Record 1    |
// ------------------
// |    Record 2    |
// ------------------
// |      ....      |
// ------------------
// |    Record n    |
// ------------------
// |    Restart 1   |
// ------------------
// |    Restart 2   |
// ------------------
// |      ....      |
// ------------------
// |    Restart m   |
// ------------------
// |  num_restarts  |
// ------------------
// 从上面的内存布局可以看到，一个Block内部可以分成两个部分，前面的Record数组
// 存放的是一些K-V记录，其顺序是根据Key值由小到大排列的。后面则是一个称为
// "重启点"的数组，存储是距离block开始处的偏移值，存放了Record数组中一些记录位置。
// "重启点"是干什么的呢？我们知道Block内部的k-v记录是从小到大排列的，这样的话，
// 相邻的两条或者多条记录的key值很有可能存在重叠部分，比如上图中的Record 1的
// key值为"my friend"，Record 2的key值为"my girlfriend"，那么两者就存在重叠部分
// "my "，为了减少key的存储量，Record 2中的key可能只存储和Record 1的key的不同部分，
// 即"girlfriend"，两者的相同部分则可以从Record 1中获取。基于上述的设计，"重启点"的
// 意思是：从这条记录开始，不再采取只存储不同的key部分，而是记录这条记录完整的
// key值，不管该记录的key值是否前一条记录有相同部分，例如Record 3就是一个重启点，
// 且他的key值为"your friend" 或者"my monther"，都将记录完整的key值，而不只是
// 和前一个记录的不同部分。而num_restarts则是"重启点"的个数。

// 前面我们说过，一个Record记录包含了k-v值，并且其中存储的key可能不是完整的key值，
// 而只是key的一部分值，那么为了适应这种设计，Record记录本身的内存布局是怎么样的呢？
// -------------------------------------------------------------
// |key共享长度|key非共享长度|value长度|key非共享内容|value内容|
// -------------------------------------------------------------
// 以上面的Record 1和Record 2为例，对于Record 2来说，key共享长度为"my "的长度，为3：
// key非共享长度为"girlfriend"的长度，为10，value长度的就是k-v的v的长度，key非共享内容
// 就是"girlfriend"，value内容就是k-v的v的内容。


// NumRestarts()方法从data_数组中根据block的内存布局获取到重启点的个数。
inline uint32_t Block::NumRestarts() const {
  assert(size_ >= sizeof(uint32_t));
  return DecodeFixed32(data_ + size_ - sizeof(uint32_t));
}

// Block类的构造函数
Block::Block(const BlockContents& contents)
    : data_(contents.data.data()),
      size_(contents.data.size()),
      owned_(contents.heap_allocated) {
  // 如果block的大小小于4字节，那么说明连一个num_restarts都放不下，这样的block是有问题的，
  // 那么就把它的大小设置为0。
  if (size_ < sizeof(uint32_t)) {
    size_ = 0;  // Error marker
  } else {
    // max_restarts_allowed存放的是一个block中最多的"重启点"个数。
    size_t max_restarts_allowed = (size_-sizeof(uint32_t)) / sizeof(uint32_t);
    if (NumRestarts() > max_restarts_allowed) {
      // The size is too small for NumRestarts()
      size_ = 0;
    } else {
      // 计算重启点数组起始地址在block中的偏移，其中一个重启点占用4字节内存，而
      // 下面的1就是指num_restarts占用的内存大小，也为4个字节，经过下面的计算
      // 就可以得出重启点数组起始地址在block中的偏移了。
      restart_offset_ = size_ - (1 + NumRestarts()) * sizeof(uint32_t);
    }
  }
}

Block::~Block() {
  if (owned_) {
    delete[] data_;
  }
}

// Helper routine: decode the next block entry starting at "p",
// storing the number of shared key bytes, non_shared key bytes,
// and the length of the value in "*shared", "*non_shared", and
// "*value_length", respectively.  Will not dereference past "limit".
//
// If any errors are detected, returns NULL.  Otherwise, returns a
// pointer to the key delta (just past the three decoded values).
// 从p指向的内存中反序列化(解码)出一个key-value信息。
static inline const char* DecodeEntry(const char* p, const char* limit,
                                      uint32_t* shared,
                                      uint32_t* non_shared,
                                      uint32_t* value_length) {
  if (limit - p < 3) return NULL;

  // 在block_builder.cc文件中，我们知道key共享长度、key非共享长度和value长度
  // 是以varint的编码格式进行存储的，无符号32位的数最少只需要一个字节就可以
  // 存放完毕，所以这里为了避免对这三部分都进行varint解码，这里尝试做一个fast path
  // 的处理，刚好这三部分都只需要一个字节就可以存储完毕，那么就对p指向内存
  // 的前三个字节取出来，如果这三部分都小于128，那么就可以直接通过前三个字节
  // 获取到上述三部分的大小，也可以直接往后偏移3个字节，即可获取指向存储非共享key
  // 的内存起始地址。如果fast path的尝试失败，那么就按照正常的方式对内存进行
  // 解码得到这三部分，解析完这三部分之后，p也就指向了存储非共享key的内存起始地址。
  *shared = reinterpret_cast<const unsigned char*>(p)[0];
  *non_shared = reinterpret_cast<const unsigned char*>(p)[1];
  *value_length = reinterpret_cast<const unsigned char*>(p)[2];
  if ((*shared | *non_shared | *value_length) < 128) {
    // Fast path: all three values are encoded in one byte each
    p += 3;
  } else {
    if ((p = GetVarint32Ptr(p, limit, shared)) == NULL) return NULL;
    if ((p = GetVarint32Ptr(p, limit, non_shared)) == NULL) return NULL;
    if ((p = GetVarint32Ptr(p, limit, value_length)) == NULL) return NULL;
  }

  // 如果非共享key起始地址到limit指向的内存地址之间的差值小于上面计算得到的
  // 非共享key长度和value长度之和，说明这个entry有问题，返回NULL；如果没有问题，
  // 则返回存储着非共享key的内存起始地址。
  if (static_cast<uint32_t>(limit - p) < (*non_shared + *value_length)) {
    return NULL;
  }
  return p;
}

// Block::Iter类定义了Block的迭代器，以Data Block为例，该类型的block中
// 存放着许多key-value记录，通过迭代器就可以获取这些key-value记录信息。
class Block::Iter : public Iterator {
 private:

  // block中存放的记录信息是大小有序的，所以需要上层调用者提供一个比较器
  // 来比较key的大小。
  const Comparator* const comparator_;

  // data_是Block中具体存放着数据的内存起始地址。
  const char* const data_;      // underlying block contents

  // restarts_是Block中"重启点"数组起始地址在Block中的偏移。
  uint32_t const restarts_;     // Offset of restart array (list of fixed32)

  // num_restarts_是Block中"重启点"数组的元素个数。
  uint32_t const num_restarts_; // Number of uint32_t entries in restart array

  // current_ is offset in data_ of current entry.  >= restarts_ if !Valid
  // current_是Block的迭代器当前指向的entry在Block中的偏移。
  uint32_t current_;

  // restart_index_是Block的迭代器当前指向的entry对应的"重启点"元素的下标。
  uint32_t restart_index_;  // Index of restart block in which current_ falls

  // key_和value_分别是是Block的迭代器当前指向的entry对应的key和value
  std::string key_;
  Slice value_;
  Status status_;

  // 迭代器比较函数，用来确定key的大小。
  inline int Compare(const Slice& a, const Slice& b) const {
    return comparator_->Compare(a, b);
  }

  // Return the offset in data_ just past the end of the current entry.
  // NextEntryOffset()函数返回Block中下一个entry起始地址在Block的偏移。
  inline uint32_t NextEntryOffset() const {
    return (value_.data() + value_.size()) - data_;
  }

  // GetRestartPoint()函数用于获取重启点数组中下标为index的重启点具体值。
  // 重启点数组中存放的重启点其实就是一些距离Block开始的偏移值，利用这些
  // 偏移值可以获取到对应的key-value记录。
  uint32_t GetRestartPoint(uint32_t index) {
    assert(index < num_restarts_);
    return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));
  }

  // SeekToRestartPoint()函数用于将迭代器由指向当前entry改变为指向重启点数组中
  // 下标为index的重启点所对应的entry。(重启点存放的是一个距离block起始地址的
  // 偏移值，起始地址加上偏移值就是一个entry的开始地址)
  void SeekToRestartPoint(uint32_t index) {
    key_.clear();

	// 将迭代器指向的当前entry对应的重启点数组中的下标更新为index。
    restart_index_ = index;
    // current_ will be fixed by ParseNextKey();

    // ParseNextKey() starts at the end of value_, so set value_ accordingly
    uint32_t offset = GetRestartPoint(index);

	// 这个地方的value_不是一个记录真正的value，这个时候临时作为一个dummy value，
	// 它的长度之所以设置为0，就是为了可以通过函数NextEntryOffset()直接获取到
	// 当前entry的起始地址。因为data_+offset其实就是重启点数组中下标为index的
	// 重启点对应的记录的其实地址。
    value_ = Slice(data_ + offset, 0);
  }

 public:
  Iter(const Comparator* comparator,
       const char* data,
       uint32_t restarts,
       uint32_t num_restarts)
      : comparator_(comparator),
        data_(data),
        restarts_(restarts),
        num_restarts_(num_restarts),
        current_(restarts_),
        restart_index_(num_restarts_) {
    assert(num_restarts_ > 0);
  }

  // 只要迭代器当前指向的entry在block中的偏移小于重启点数组的起始地址，
  // 那么可以认为它就是有效的。如果block的迭代器无效，那么它一定指向了
  // block的数据部分末尾，即重启点数组开始的位置。
  // 不管迭代器是因为指向第一条记录再往前移动导致的无效，还是指向最后一条记录再往后移动导致
  // 的无效，其最终都会使得迭代器指向block的数据部分的末尾，重启点数组的开始位置。这部分可以
  // 参考block.cc中Prev()的实现注解。
  virtual bool Valid() const { return current_ < restarts_; }
  virtual Status status() const { return status_; }

  // key()用于获取迭代器当前指向的entry的key。
  virtual Slice key() const {
    assert(Valid());
    return key_;
  }

  // value()用于获取迭代器当前指向的entry的value。
  virtual Slice value() const {
    assert(Valid());
    return value_;
  }

  // 更新迭代器指向的entry为当前entry的下一个entry。
  virtual void Next() {
    assert(Valid());
    ParseNextKey();
  }

  // 更新迭代器指向的entry为当前entry的上一个entry。
  virtual void Prev() {
    assert(Valid());

    // Scan backwards to a restart point before current_
    // 保存迭代器当前指向的entry在block中对应的偏移值。
    const uint32_t original = current_;

	// 我们知道一个entry对应的重启点entry的偏移值肯定是要小于等于这个记录在block
	// 中的偏移值的，所以我们需要更新restart_index_的值，使重启点数组中下标为
	// restart_index_的重启点对应的entry会是迭代器当前指向的entry的上一个entry对应的
	// 重启点entry。
	// ------------------------重要---------------------------
	// 这个循环有一个特殊的地方，就是当迭代器当前所指向的位置就是block中第一条记录
	// 的位置，这个时候再调用Prev()，那么迭代器就应该失效。这种情况该如何实现呢？
	// 在这种情况下，original等于0，restart_index_等于0，那么以0作为参数调用函数
	// GetRestartPoint()，函数的返回值也为0，那么就可以进入这个循环，进入循环之后
	// 接着判断restart_index_等于0为真，那么就会进入到if语句中，然后将current_设置
	// 为restarts_，restart_index_设置为num_restarts_，这样的话，这个迭代器就无效了
	// 即调用迭代器的Valid()判断时就会返回false。所以只要是迭代器无效，那么其总是会
	// 指向block的数据部分末尾，重启点数组的开始。
    while (GetRestartPoint(restart_index_) >= original) {
      if (restart_index_ == 0) {
        // No more entries
        current_ = restarts_;
        restart_index_ = num_restarts_;
        return;
      }
      restart_index_--;
    }

    // 将迭代器由指向当前entry改变为指向重启点数组中下标为restart_index_的重启点所
    // 对应的entry。(重启点存放的是一个距离block起始地址的偏移值，起始地址加上偏移值
    // 就是一个entry的开始地址)。在这个基础上我们尝试从这个重启点entry开始往后偏移，
    // 直到偏移后的entry的偏移值是小于original的最大值。那么就完成了迭代器前移功能。
    SeekToRestartPoint(restart_index_);
    do {
      // Loop until end of current entry hits the start of original entry
    } while (ParseNextKey() && NextEntryOffset() < original);
  }

  // Seek()函数用于让迭代器指向key值不小于target的第一个entry。其采用了二分法的思想
  // 来查找目标的entry，因为block中的entry是key有序的所以用二分法可以提高效率。
  virtual void Seek(const Slice& target) {
    // Binary search in restart array to find the last restart point
    // with a key < target
    uint32_t left = 0;
    uint32_t right = num_restarts_ - 1;
    while (left < right) {
      uint32_t mid = (left + right + 1) / 2;
      uint32_t region_offset = GetRestartPoint(mid);
      uint32_t shared, non_shared, value_length;
      const char* key_ptr = DecodeEntry(data_ + region_offset,
                                        data_ + restarts_,
                                        &shared, &non_shared, &value_length);
      if (key_ptr == NULL || (shared != 0)) {
        CorruptionError();
        return;
      }
      Slice mid_key(key_ptr, non_shared);
      if (Compare(mid_key, target) < 0) {
        // Key at "mid" is smaller than "target".  Therefore all
        // blocks before "mid" are uninteresting.
        left = mid;
      } else {
        // Key at "mid" is >= "target".  Therefore all blocks at or
        // after "mid" are uninteresting.
        right = mid - 1;
      }
    }

    // Linear search (within restart block) for first key >= target
    SeekToRestartPoint(left);
    while (true) {
      if (!ParseNextKey()) {
        return;
      }
      if (Compare(key_, target) >= 0) {
        return;
      }
    }
  }

  // SeekToFirst()函数用于让迭代器指向block中的第一个entry。
  virtual void SeekToFirst() {
    SeekToRestartPoint(0);
    ParseNextKey();
  }

  // SeekToLast()函数用于让迭代器指向block中的最后一个entry。其具体做法就是
  // 首先让迭代器指向最后一个重启点区间的首个entry，然后从这个entry开始往后
  // 偏移，直到达到重启点数组首地址为止。
  virtual void SeekToLast() {
    SeekToRestartPoint(num_restarts_ - 1);
    while (ParseNextKey() && NextEntryOffset() < restarts_) {
      // Keep skipping
    }
  }

 private:
  void CorruptionError() {
    current_ = restarts_;
    restart_index_ = num_restarts_;
    status_ = Status::Corruption("bad entry in block");
    key_.clear();
    value_.clear();
  }

  // ParseNextKey()用于解析迭代器当前指向的entry的下一个entry，并更新迭代器使其
  // 指向被解析的entry，从而完成迭代器后移的功能。其实迭代器的后移是通过current_和
  // restart_index_两个变量实现的，因为这两个变量真正决定着迭代器指向block中的
  // 具体entry。
  bool ParseNextKey() {

    // 获取迭代器当前指向的entry的下一个entry距离block头部的偏移，并设置到current_，
    // 这么做是为了让迭代器后移指向被解析的entry。
    current_ = NextEntryOffset();

	// p指向了迭代器当前指向的entry(被解析的entry)的起始地址。
    const char* p = data_ + current_;
    const char* limit = data_ + restarts_;  // Restarts come right after data
    if (p >= limit) {
      // No more entries to return.  Mark as invalid.
      current_ = restarts_;
      restart_index_ = num_restarts_;
      return false;
    }

    // Decode next entry
    // 解析这个即将被迭代器指向的entry(迭代器后移操作只完成了一半，因为restart_index_
    // 还没有更新)。我们知道在迭代器完成后移操作之前，除了前面步骤已经更新的current_，
    // 其余比如key_，value_，restart_index等信息都还没有做相应的更新，所以这部分值存储
    // 的仍然是上一个entry的信息。所以等解析完当前这个entry之后，计算出key的共享长度，
    // 非共享长度和value长度之后，我们可以直接通过key_.resize(key的共享长度)获取到当前
    // entry和之前entry的共享部分，然后在这个基础上追加非共享部分，就可以获取到完整的
    // key信息了。
    uint32_t shared, non_shared, value_length;
    p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);
    if (p == NULL || key_.size() < shared) {
      CorruptionError();
      return false;
    } else {
      // 更新key和value
      key_.resize(shared);
      key_.append(p, non_shared);
      value_ = Slice(p + non_shared, value_length);

	  // 这个地方就是根据迭代器后移的情况看是否需要调整restart_index_的值。这个时候需要
	  // 分两种情况讨论，一种是迭代器后移一个记录之后，这个记录不是一个重启点对应的记录，
	  // 那么这个记录对应的重启点和上一个记录对应的重启点是一样的，那么就不需要更新
	  // restart_index_；另外一种是迭代器后移一个记录之后，刚好这个记录就是一个新的重启点
	  // 对应的首个记录，这种情况下就需要更新restart_index_。因为一个记录对应的重启点记录
	  // 的偏移肯定是要小于等于这个记录的。
      while (restart_index_ + 1 < num_restarts_ &&
             GetRestartPoint(restart_index_ + 1) < current_) {
        ++restart_index_;
      }
      return true;
    }
  }
};

// NewIterator方法是用来创建一个Block对象的迭代器，通过这个迭代器就可以遍历
// Block中存放的key-value记录了。
Iterator* Block::NewIterator(const Comparator* cmp) {
  if (size_ < sizeof(uint32_t)) {
    return NewErrorIterator(Status::Corruption("bad block contents"));
  }
  const uint32_t num_restarts = NumRestarts();
  if (num_restarts == 0) {
    return NewEmptyIterator();
  } else {
    return new Iter(cmp, data_, restart_offset_, num_restarts);
  }
}

}  // namespace leveldb
